#数据结构


##Hash
其结构是使用数组来完成的，数组中每个位置存储的是一个链表，来解决冲突问题（也可以直接把数据顺延存储来解决冲突）。在哈希表插入数据时，首先相关对象会实现自己的 哈希函数 hashCode() 方法，哈希表内部会调用这个方法计算其 hash值 然后对当前数组求余来映射到数组具体位置。  
数组的长度应为素数；因为分析发现，如果不是用质数来做模运算的话，很多生活中的数据分布，会集中在某些点上。  
有俩个关键参数：initialCapacity 标识初始化的数组大小，loadFactor 标识 装填因子；如果 $\displaystyle\frac{实际装入数据量}{数组容量}$ 大于 装填因子，就会触发 resize函数执行，重新申请存储空间（例如2倍大的另一个素数），重新计算所有数据的 hash值，并进行安置，非常耗时；所以最好创建的时候指定 Hash表 的 capacity。  

Java 内置的几个哈希表：  
- HashMap 线程不安全，容许 null 作为 Key或Value；另外相关基类应该比 HashTable 要新  
- HashTable 线程安全，因为操作函数都添加了 synchronized 关键字

其实 HashSet 也是基于 HashMap 实现的，不过它仅仅是一个单一 Set集合，而不是存储 Key-Value 的哈希表

#多线程


#垃圾回收 GC（Garbage Collection） 
**（作者大四的毕设...）**  
垃圾回收是对堆中对象的管理；其最基本的算法是 根搜索算法（GC Roots Tracing），应该也能称为 标记清除算法（Mark-Sweep）。其通过对一系列的 root对象 节点展开搜索，遍历标记整个引用关系链，对于不可达的对象进行回收；相比于直接的引用计数，可以解决不可达对象之间循环引用造成的内存泄漏。另外一个细节是，如果对象实现了 finalize 方法，将会被加入 F-Queue队列 中，之后虚拟机另开一个线程帮助有关对象完成最后操作；finalize方法仅执行一次，即使这次获救，二次被标记后对象将被直接清除  
用户可以通过调用 System.gc() 来要求垃圾回收，但是相关 Java虚拟机（JVM，Java Virtual Machine） 不一定执行  
另外的常用算法有 复制算法（Copying），标记整理算法（Mark-Compact），分代收集算法（Generational Collection）

##几种引用方式（一般我们都只用 Direct Reference）
详细来说，标记清除针对的是 Direct Reference；Java 来设计了不同级别的引用，来灵活用户的内存管理  

- StrongReference 强引用（Direct Reference），普通地 new 一个对象的场景，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象  

- SoftReferences  软引用，指到的对象，即使没有任何 Direct Reference，也不会清除，一直到vm内存不足且没有 Direct Reference 时候才会清除。一般用于非重要数据的缓存，例如一些旧查询结果的缓存  

- WeakReferences  弱引用，弱引用的对象拥有比 SoftReferences 更短暂的生命周期当垃圾回收器扫描的时候不管内存够不够，如果发现了弱引用的对象，都会回收；Android 里 Activity 的 Handler 中常使用这个弱引用来保存 Activity 引用，以防内存泄漏  

- PhantomReferences   虚引用，顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收；虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。


##Android 4.0 Dalvik 的几种内存回收方式
**垃圾回收机制的终极目标是，回收任务不影响系统性能，而且用户在任何想要内存的时候都能立即分配！**

- GC_FOR_MALLOC，是轻量级的，当系统创建对象时突然空间不够了，调用其补充一点内存。所以它不用回收很多空间，它被设置为了局部和容忍软引用的。但是，系统这个时候是急着用内存的，所以它不是并发的，它会一直挂起其他所有线程，迅速完成回收，把内存提供给要创建的对象  

- GC_CONCURRENT，是系统优化的一个方式，系统经常会调用这个回收，这是一个轻量级地高频率过程，所以仅仅优化局部关键区域，并容忍软引用。并且，这个优化过程并不着急拿到内存空间，所以是并发执行，尽量不影响其他线程  

- GC_EXPLICIT，是标准的回收过程，这是由系统发起的标准回收，应该是当系统发现整个内存吃紧的情况下，统一进行的内存回收，频度较低，选择的是全范围的回收，并且这个过程也不由用户控制，系统也不着急，所以是并发过程  

- GC_BEFORE_OOM，系统救急的方式，一看名字就非常紧急，是系统内存不足前的最后挣扎，内存不足的话相关程序就无法执行了，所以这次回收关系重大，全范围零容忍的回收内存，并且不并发，最快速度搞到内存挽回崩溃。
