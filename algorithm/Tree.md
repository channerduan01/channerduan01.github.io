#二叉树（Binary Tree）
二叉树相关处理时，注意尽量使用递归，这样可以大幅简化代码；自己控制栈的话，通常要维持很复杂的节点状态。  
- 完全二叉树（Complete Binary Tree）：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点（堆结构就是完全二叉树）  
- 满二叉树（Full Binary Tree）：除最后一层外，每一层上的所有结点都有两个子结点

#平衡二叉树
常用的 map（也可以说dictionary，用于存储、索引 Key-Value 数据） 实现方式，查找的时间复杂度为 $O(logN)$；另一种 map 的实现方式是 hash（哈希表），其查找的时间复杂度为 $O(1)$，如果相关操作对象有非常好的哈希函数，而且额外内存消耗（空间换时间~）可以接受，就可以用哈希表

##AVL树（Adelson-Velskii and Landis Tree）
**本身这是二叉搜索树，附带平衡条件（balance condition）：每个结点的左右子树的高度之差最多为1。**平衡的二叉树保证了我们高效率 $O(log_2N)$ 的查询；但是当插入或删除节点，导致树结构改变的时候，需要通过耗时的旋转操作来重新平衡；所以AVL树适用于查找量大，但是插入删除少的场景

##红黑树（Red Black Tree）
**本身也是二叉搜索树，其平衡条件相对 AVL树 放宽：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。**这是相对平衡的树，插入删除次数多的情况下我们就用红黑树来取代AVL，以查找的性能损失来换取插入删除的性能优势；其被广泛应用于C++ STL（set、multiset、map、multimap），哈希表和平衡树会有权衡使用的场景

#B树，B+树
与自平衡二叉查找树不同，是多路查找树，每个节点可以拥有多个分支，所以分支多层数少，减少了定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。大规模数据的索引本身就很大，只能存在外存，而磁盘IO非常耗时，所以使用这种矮的树结构进行数据索引。B+树属于B树的变种，其非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历

#Trie树
又名单词查找树，一种树形结构，常用来操作字符串。它是不同字符串的相同前缀只保存一份。
相对直接保存字符串肯定是节省空间的，但是它保存大量字符串时会很耗费内存（是内存）  
类似的还有：  
前缀树：字符串快速检索，字符串排序，最长公共前缀，自动匹配前缀显示后缀。  
后缀树：查找字符串s1在s2中，字符串s1在s2中出现的次数，字符串s1,s2最长公共部分，最长回文串。
