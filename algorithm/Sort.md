# 各个方法概要比较
| 排序方法         | 平均时间           | 最优时间           | 最差时间           | 空间      | 稳定      |
| ------------- |-------------|-------------|-------------|---------|---------|
| Insert 插入排序      | $O(n^2)$ | $O(n)$，顺序 | $O(n^2)$，逆序 | $O(1)$ | 稳定 |
| Shell 希尔排序      | $O(n^{1.3})$ | $O(n)$，顺序 | $O(n^2)$，各层皆逆序 | $O(1)$ | 不稳定 |
| Selection 选择排序      | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定 |
| Heap 堆排序      | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(1)$ | 不稳定 |
| Bubble 冒泡排序      | $O(n^2)$ | $O(n)$，顺序 | $O(n^2)$，逆序 | $O(1)$ | 稳定 |
| Quick 快速排序      | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n^2)$，顺序或逆序 | $O(nlog_2n)$ | 不稳定 |
| Merge 归并排序      | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n)$ | 稳定 |


# 关于时间消耗：

- Bubble 冒泡排序 的最优时间消耗的话，需要算法实现的时候安插一个 flag 标识值交换；当一次全量 for 迭代内没有产生交换操作时，则可以直接确认整个序列已经顺序
- Quick 快速排序 的最优时间消耗是在轴枢每次正好可以二分当前序列时发生的；如果轴枢（默认选择序列中第一个数字）每次都在开头或者结尾（整个序列顺序或逆序），则成为最差 case。这个点可以优化，可以每次选择轴枢时，随机指定序列中一个数为轴枢，把这个数交换到序列第一个位置，然后再用默认方法处理

# 关于稳定性
稳定就是指同一个key的一堆元素，在排序前后是否保持顺序。以下是几个算法不稳定的栗子：

- Selection 选择排序 是 不稳定 的；俩个一样的数，靠前的一个，可以能被交换到他们后面的序列中，这样相同数的原始顺序就被破坏了，不稳定
- Quick 快速排序 是 不稳定 的；因为 枢轴 pivot 在寻找位置，交换左右侧元素时可能造成乱序，如：5，7，7，1，1 这样的序列，选择 pivot 为 5，最终结果是 1，1，5，7，7；这个过程中 7 的顺序被交换操作破坏了
- Heap 排序 是 不稳定 的；因为它的层次结构本身就可以造成乱序，例如所有元素都是一个值时，显然乱序了


