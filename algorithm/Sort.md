#各个方法比较
| 排序方法         | 平均时间           | 最优时间           | 最差时间           | 空间      | 稳定      |
| ------------- |-------------|-------------|-------------|---------|---------|
| Insert 插入排序      | $O(n^2)$ | $O(n)$，顺序 | $O(n^2)$，逆序 | $O(1)$ | 稳定 |
| Shell 希尔排序      | $O(n^{1.3})$ | $O(n)$，顺序 | $O(n^2)$，各层皆逆序 | $O(1)$ | 不稳定 |
| Selection 选择排序      | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定 |
| Heap 堆排序      | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(1)$ | 不稳定 |
| Bubble 冒泡排序      | $O(n^2)$ | $O(n)$，顺序 | $O(n^2)$，逆序 | $O(1)$ | 稳定 |
| Quick 快速排序      | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n^2)$，顺序或逆序 | $O(nlog_2n)$ | 不稳定 |
| Merge 归并排序      | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n)$ | 稳定 |


#一些细节
- Bubble 冒泡排序 的最优时间消耗的话，需要算法实现的时候安插一个 flag 标识值交换；当一次全量 for 迭代内没有产生交换操作时，则可以直接确认整个序列已经顺序
- Selection 选择排序 是 不稳定 的；俩个一样的数，靠前的一个，可以能被交换到他们后面的序列中，这样相同数的原始顺序就被破坏了，不稳定
- Quick 快速排序 的最优时间消耗是在轴枢每次正好可以二分当前序列时发生的；如果轴枢（默认选择序列中第一个数字）每次都在开头或者结尾（整个序列顺序或逆序），则成为最差 case。这个点可以优化，可以每次选择轴枢时，随机指定序列中一个数为轴枢，把这个数交换到序列第一个位置，然后再用默认方法处理