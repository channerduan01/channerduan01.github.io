## 1. 操作系统概述

主要功能：

- 管理&分配资源
	- 硬件：处理机CPU处理（进程的状态、前驱图、PV操作）、存储器管理（逻辑地址、物理地址、存储方案）、设备管理（输入输出控制方式）
	- 软件：文件管理（文件索引）
- 用户接口（例如命令行指令交互、可视化操作系统）


## 2. 进程
进程 三状态模型：运行<->就绪<-阻塞<-运行

- 运行态：进程正在使用CPU
- 就绪态：已经具备执行条件，仅排队等待CPU调度
- 阻塞态：等待外部事件发生

进程定义：通常由程序、数据集合、进程控制块 PCB-Process Control Block 组成。PCB是一种数据结构，是进程存在的唯一标识。

PCB数据结构：

- 线性方式：所有PCB组织在一张线性表中；查询需要扫全表
- 链接方式：同样在连续空间中，相同状态的PCB通过链接字（指针）链接成队列；查询只需要扫相应状态的队列（通过指针标识某状态的PCB首地址）
- 索引方式：相同状态的PCB归入一个索引表，多个状态对应多个索引表；查询扫相应状态的索引表

前驱图-进程间的同步关系（先后顺序）：
有向无循环图，由节点和有向边组成；节点表示进程，有向边表示前驱关系（反向依赖关系，被指向方必须等待指方执行完毕）。用于描述多个程序/进程之间的执行顺序关系。


## 3. PV操作
属于 Semaphore 信号量（代码里面常写为 mutex） 技术。

### 3.1 互斥问题
#### 定义
某资源只允许n个（常见n=1）进程同时使用。

#### 解法
所有进程：

- 进入临界区之前先执行P操作（可能阻塞当前进程，相当于加锁）
- 离开临界区之后再执行V操作（可能唤醒某个进程，相当于解锁）

进一步来说，信号量S初始化为资源的个数（要求资源独立访问的话S=1），PV操作实际上是操作信号量S：

- P操作：对信号量S-1即S=S-1，如果S>=0则该进程继续执行，否则进入等待状态
- V操作：对信号量S+1即S=S+1，如果S>0则该进程继续执行，否则去等待队列唤醒一个进程

若当前信号量为负，则说明有进程在等待；S=-n则说明有n个进程正在等待。

### 3.2 同步问题
#### 定义
进程运行之间有依赖关系，例如生产者&消费者，进程前驱关系（前面提到的前驱图）。

#### 解法
所有进程：

- 运行不满足条件时，能让进程暂停（在关键操作前执行P操作）
- 运行条件满足时，能让进程继续（在关键操作后执行V操作）

关键操作：如果操作影响到后续进程间的合作行为，就称为关键操作

#### 生产者&消费者场景
m个生产者进程，n个消费者进程，缓冲区大小为k；生产者不能写已经满的缓冲区，消费者不能读已经空的缓冲区。

需要设定2个信号量来解决：
- empty=k，初始化缓冲区有k个空位
- full=0，初始化缓冲区有0个填充数据

具体运行过程
- 生产者：生产一条数据->p(empty)->“写入缓冲区一条数据”->v(full)
- 消费者：p(full)->“读取缓冲区一条数据”->v(empty)->消费一条数据

总的说就是识别到关键操作，操作前增加P操作，操作后增加V操作。

#### 前驱图场景
进程前驱图本身可以作同步问题解决：

- 前驱图的每一条边（前驱关系）作一个信号量，并且信号量编号是从左到右，从小到大，从前驱上游到下游
- 所有信号量初始化为0（全部进入阻塞），每个进程开始前对所有上游信号量执行P操作，结束后对所有下游信号量执行V操作
- 前驱图的最上游进程不需要P操作，最下游进程不需要V操作


## 4. 存储管理
按照计算机基础讲过的存储架构：
CPU->缓存Cache->内存（主存，也可直接和CPU交互）->外存（辅存）

这里主要讲内存相关逻辑。所有的程序都需要加载进入内存，才能和CPU交互，才能运行。

### 4.1 外存->内存 地址重定位
定义：是指将程序中的地址虚拟地址（逻辑地址）变换成内存的真实地址（物理地址）的过程。

- 逻辑地址：相对地址。CPU所生成的地址，供内部和编程使用，并不唯一。
- 物理地址：绝对地址。加载到内存地址寄存器中的地址，内存单元的真正地址。

具体方法：

- 静态重定位：绝对地址=相对地址+程序存放的内存起始地址
	- 程序运行前就确定了所有映射关系
	- 程序装入后不能移动，并且需要占用连续的内存空间
- 动态重定位：绝对地址=重定位寄存器的值（BR）+逻辑地址寄存器的值（VR）
	- 程序占用空间可动态变化并且可以不连续，且便于多个进程共享代码

### 4.2 内存管理
几种管理类型：分区存储管理、分页存储管理、分段存储管理、段页式存储管理、虚拟存储管理

#### 分区管理
特点：都是要求程序载入一块连续的空间。
把主存的用户区（备注：系统区是操作系统使用，这里不讨论）划分称若干个区域，每个区域分配给一个用户作业使用，并限定他们只能在自己的区域中运行。又可分为：

- 固定分区：静态确定各个区大小、起始地址。实践中程序和分区大小不一定匹配，可能会浪费很多空间。
- 可变分区：（事先有一定的预分区）运行时根据载入程序大小动态调整分区（扣减程序大小），载入时内存分配具体又分3个策略：
	- 首次适应算法：从上到下选择第一个可载入的分区
	- 最佳适应算法：选择可载入的最小分区（尽量保留连续的大空间），可能会产生很小的碎片
	- 最差适应算法：选择可载入的最大分区（尽量干掉连续的大空间），可能会导致大程序无法装入
- 可重定位分区：在“可变分区”的基础上，叠加可以重新整理存储空间的能力，把碎片化的未使用空间整理成连续空间。日常大多采用这一模式。

#### 分页管理
特点：程序可载入不连续的空间，分页标准（页&块的大小）是全局的。
将一个进程的地址空间划分成若干个大小相等的区域，称为页。相应地，将主存空间划分成与页相同大小的若干个物理块，称为块或页框。

- 逻辑地址：页号（通常是20位二进制表示）+页内地址（通常12位二进制表示，整体32位二进制）
- 物理地址：块号（由页号映射）+块内地址（通常和页内地址完全一致）
- 页表：记录“页号”-“物理块号”映射关系；页表控制寄存器通过“页表始址”+“页号”求得对应物理块号，会有地址越界校验。

示例：
假设需要访问逻辑地址=2100，而页&物理块大小均为1024B；
则 页号=2100/1024=2，页内地址=2100%1024=52；然后通过页表翻译页号到物理块例如8，则物理地址=8*1024+52=8244

#### 分段管理
特点：程序可载入不连续的空间，分段标准是根据具体程序决定的，更加灵活。
和分页管理的差异：

- 页大小全局固定、段大小不同进程可以不一致
- 页大小对应物理块大小，段没有对应的物理块而是直接指向具体地址
- 页表记录“页号”-“物理块号”，段表记录“段号”-“段长度”-“段基址”（“段长度”-“段基址”即具体物理地址）

将一个进程的地址空间划分成若干个大小相等的段，离散地存放到内存中。系统为每个进程建立一张“段表”，来映射物理地址。

- 逻辑地址：段号+段内地址
- 物理地址：段基址（由段号映射）+段内地址
- 段表：段表寄存器通过“段表始址”+“段号”求得物理地址（“段长度”+“段基址”），同样会有地址越界校验。

#### 段页式管理
特点：整合段式&页式管理
将主存空间整体划分与页相同的物理块/页框；对于具体程序做分段，段内再进行一次分页。

- 逻辑地址为：段号+段内页号+页内地址。
- 物理地址为：块号+块内地址；块号=页号基准（由段号映射）+段内页号，块内地址=页内地址

#### 虚拟存储
上述存储管理方案都需要程序完整装入内存，当内存空间不够就无法执行程序。
虚拟存储只把部分装入主存便能执行程序，其余部分待需要时再装入主存。
上述管理方式又称为基本分页存储、基本分段存储、基本段页式存储，叠加虚拟存储后称为：请求分页存储、请求分段存储、请求段页式存储。


## 5. 文件存储

### 5.1 文件存储管理
文件通过索引方式存储，索引中存放文件相关具体的物理盘块。

- 直接索引：索引直接指向具体物理盘块。查询速度快，但是检索空间小（1个索引->1个物理盘块）。
- 间接索引：常见一级间接索引、二级间接索引、三级间接索引，即索引并不指向物理块，而是指向另一个索引块（块中又包含大量索引）；最后一层索引指向具体物理块。检索空间非常大（例如一级间接索引，1个索引->n个索引->n个物理盘块）。

常见规律：

- 地址项（单条索引）大小通常为 4字节（4B）
- 索引块大小=物理盘块大小，单个索引块中索引数=索引块大小/地址项大小，例如4KB/4B=1K=1024（注意计算机中的K是1024）

### 5.2 文件存储设备管理
常使用“位视图法”：在外存建立一张位视图（Bitmap），记录文件存储器的使用情况。每个二进制位唯一对应文件存储器上的一个物理块，取值0/1分别表示空闲/占用。

位视图由n个字，每个字k个位构成，总计可以标识n*k个物理块。注意“字号”、“位号”一般都是从0开始编号。


## 6. 设备管理

一般分为3种工作方式： 

- 程序控制（CPU串行工作）：
	- 无条件传送：I/O端口总是就绪的，CPU需要时直接访问
	- 程序查询：CPU必须不停地测试I/O设备状态端口（检查设备是否就绪）
- 中断（CPU并行工作）：与I/O设备和CPU通过中断的方式做交互，CPU完成指令/数据传递后（例如给打印机传递完成待打印内容）返回原来的工作，CPU和设备可以并行工作
- DMA-Direct Memory Access（CPU并行工作）：通过DMA控制器建立I/O设备和内存的数据通路，数据交互过程无需CPU接入
